Ques::: what i call api in flutter and want to stop at any time how to use to do that
Ans:::: The http package doesn’t support cancelling a request directly.
         But you can use http.Client and close it to stop ongoing requests.
     http.Client? _client;
    _client = http.Client();
    _client?.close();
    ////
    👉 dio has built-in cancel tokens (recommended if you need cancellation often).
     final Dio _dio = Dio();
      CancelToken? _cancelToken;
 --------------------------------------------------------------------------------
 Ques::: can we call multiple fragments in same activity
 ANS ::: WITH frame layouts Yes 👍 In Android you can have multiple Fragments in the same Activity
  — that’s actually one of the main purposes of Fragments:
  to build flexible UIs by combining multiple components inside a single Activity.

 --------------------------------------------------------------------------------
 Ques::: What is the difference between ConstraintLayout and RelativeLayout?
 ANS ::: 👍RelativeLayout

          Older layout (introduced before ConstraintLayout).

          Allows positioning of child views relative to the parent or other sibling views.

           <Button
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="Click"
                  android:layout_below="@id/title"
                  android:layout_alignParentEnd="true" />

         while   ConstraintLayout
         Strong Studio support (drag-and-drop)
 --------------------------------------------------------------------------------
 Ques::::What is the difference between synchronous and asynchronous tasks in Android?
        👍 1. Synchronous Tasks

        Meaning: Tasks run one after another, in sequence.

        Blocking: The current thread (like the Main/UI Thread) is blocked until the task finishes.

    2. 2. Asynchronous Tasks

    Meaning: Tasks run in the background thread, letting the UI thread stay free.

    Non-blocking: App stays smooth while waiting.

    How in Android:

    Kotlin Coroutines (launch, async, withContext)

    Old way: AsyncTask (deprecated)
 --------------------------------------------------------------------------------
Ques:::: 8. What is the difference between dp, sp, and px in Android?

 Ans::::  👍 dp (density-independent pixels) → Used for UI layout sizes (scales with screen density).

        sp (scale-independent pixels) → Used for text sizes (scales with user’s font settings).
 --------------------------------------------------------------------------------
 Ques::::   Activities go through stages like human life:

         onCreate() → called when Activity is created (setup UI here).

         onStart() → activity becomes visible.

         onResume() → activity is in foreground & interactive.

         onPause() → another screen is in front.

         onStop() → activity is hidden.

         onDestroy() → activity is destroyed.
 --------------------------------------------------------------------------------
Ques::::20. What is the difference between LiveData and StateFlow?

        LiveData → Lifecycle-aware, emits values to UI.

        StateFlow → Modern alternative using Kotlin Flow, works better with Coroutines.

        If you are working in legacy or Jetpack UI (XML) → use LiveData.

        If you are using Jetpack Compose + Coroutines → prefer StateFlow.
--------------------------------------------------------------------------------
Ques:::: Isolates in flutter

    Sending multiple messages between isolates with ports
    #to perform heavy task on main UI trade without lock the current actions using received port
    send port
    To do this, you can use some of the low-level isolate APIs that Isolate.run abstracts:

    Isolate.spawn() and Isolate.exit()
    ReceivePort and SendPort
    SendPort.send() method


    explain You don’t manually call Isolate.spawn() here.
     Flutter’s compute is a shortcut for isolates.

     like await compute(runHeavyLoop, null);

     // ---- HEAVY FUNCTION ----
     void runHeavyLoop(dynamic _) {
       for (int i = 0; i < 100000000; i++) {
         if (i % 10000000 == 0) {
           log("Progress: $i");
         }
       }
     }
-----------------------------------------------------------------------------------------------------------
Ques::::when you call an API in Flutter (Dart), there are many possible exceptions and errors

   SocketException → No internet connection, DNS failure, server not reachable.

        HttpException → Invalid HTTP response.

        TimeoutException → Server took too long to respond.

 try {
   code to generate exceptions
  } on SocketException {
    print("❌ No Internet connection");
  } on TimeoutException {
    print("❌ Request timed out");
  } on FormatException {
    print("❌ Invalid JSON format");
  } on HttpException {
    print("❌ Invalid HTTP response");
  } catch (e) {
    print("❌ Unexpected error: $e");
  }
 -----------------------------------------------------------------------------------------------------------

Ques:::: what is .env and how to read it.
 (secure level or you can fetch apis from backend through get apis)

ANS :::A .env file is a text file where you keep your environment variables (API keys, secrets,
        base URLs, configs).
        API_KEY=12345abcde
        API_secret=12345abcde
        like wise in this file Change API endpoint ,keys or feature flag without touching code.
      1. flutter_dotenv: ^5.1.0 >>> add package.
      2. flutter pub get >>>>> command run
      3. In your project root, create a file called .env
      4. Add .env to .gitignore so you don’t push secrets to GitHub.
      5 . Load .env in main.dart
          import 'package:flutter_dotenv/flutter_dotenv.dart';
          await dotenv.load(fileName: ".env"); before runApp()
      6.Access variables anywhere
      final apiSecret = dotenv.env['API_secret'];
      final apiKey  = dotenv.env['API_KEY'];

 -----------------------------------------------------------------------------------------------------------

 Ques:::: send data flutter to native and then on the basis of data show some data back
 ANS:::: flutter END>>>>>>
             static const MethodChannel _channel = MethodChannel('wrazzle_native_call_view');
             final val data ={"point":"5"};
             final bool sims = await _channel.invokeMethod('spendUserPointTapjoy', data);
              return sims;
          Native end>>>>>
              new MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL_name).
                  setMethodCallHandler((call, result) -> {
              if (call.method.equals("spendUserPointTapjoy")) {
                  int balance = call.argument("point"); // called data here
              }
              }
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
Ques:::: what is linter how you do tree shaking
ANS:::: Lint packages provide rules for code style, best practices, and error prevention in Dart & Flutter projects.
             it will give warning and errors and you need to resolve it forcefully
             during development phase itself
             flutter_lints: ^4.0.0 >>>>>> Add package
             analysis_options.yaml >>> add  tp project root, create or edit
             contains >>
                     include: package:flutter_lints/flutter.yaml

                        linter:
                          rules:
                            # Prevent keeping unused imports
                            unused_import: error

                            # (optional) other useful rules
                            avoid_print: true
                            prefer_const_constructors: true
                            unnecessary_this: true

             flutter analyze >>> command to show errors now



---------------------------------------------------------------------------------------------------------------------------------------------------------------
Ques::::one-liner difference for each Flutter CI/CD tool:
ANS::::Codemagic → Flutter-focused CI/CD platform with built-in mobile build, test, and deploy pipelines.

       Shorebird → Hot-update service for Flutter apps (push code changes to users without full app store resubmission).

       Frontlane → Lightweight CI/CD tool built specifically for Flutter projects (simpler than Codemagic).

       GitHub Actions → General CI/CD automation for any project (including Flutter) inside GitHub repos.

       we can upload screenshots in automatic build in codemagic and frontlane using fastlane for ios AND
       screengrab for in workflow


       =====In GitHub Actions===== root <> your-project/.github/workflows/<workflow-name>.yml

       By default → all jobs run in parallel 🏃🏽‍♂️🏃🏽‍♀️ simultaneously

       If you want one job to run after another, you use "needs":
       like below
       jobs:
         test:
           runs-on: ubuntu-latest
           steps:
             - run: flutter test

         build:
           needs: test   # 👈 build runs only after test finishes
           runs-on: ubuntu-latest
           steps:
             - run: flutter build apk --release

       =====In Codemagic=====

            Each workflow runs separately.Codemagic doesn’t have a jobs: concept like GitHub Actions. Instead:

            Inside a workflow, the scripts run sequentially (one by one).

            To run parallel pipelines, you define multiple workflows in codemagic.yaml.

            workflows:
              android_build:
                name: Android Build
                max_build_duration: 60
                instance_type: linux_x2
                scripts:
                  - flutter pub get
                  - flutter build apk --release
                artifacts:
                  - build/app/outputs/flutter-apk/app-release.apk

              ios_build:
                name: iOS Build
                max_build_duration: 60
                instance_type: mac_mini_m2
                scripts:
                  - flutter pub get
                  - flutter build ipa --release
                artifacts:
                  - build/ios/ipa/*.ipa
            👉 Here you have two workflows:

            android_build

            ios_build
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
Ques::::
ANS::::
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
Ques::::
ANS:::::